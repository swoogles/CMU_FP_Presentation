How to start living and loving the fantasy world of software
-The real world has so many flaws:
  - Decay
  - Malfunction
  - Natural Disasters
  - Human treachery
  - Human incompetence
- By interacting with it only when absolutely necessary, we can experience
  undreamed-of consistency.
- We need only trust that the laws of nature (components of the processor) are
  functioning properly in order to have complete confidence in our universe.

You can actually get the perfect assassin in this world.
Version of mutation
  void mutator -> "This guy says he murdered the target."
  int mutator -> "This guy says he murdered the target, and that it took 3 stabs to finish the job.
  new version -> "This guy says he murdered the target and then he mailed us the body with 3 stab wounds in it."
  Which version do you trust to get the job done?
  
  kill(Target): Unit // *Stairs at you silently*
  kill(Target): String // "Alright, I'll kill him."
  kill(Target): Int // Indicate number of bullets.
  kill(Target): Target // Return the actual body.
  kill(Target): Picture[Target] // For when the target is too large to send back

Possible items to construct/manipulate:
  -Sculpture
  -Bicycle
  -Car
  -Messaging System
  -Routing System
    -Destination algorithm
    -Queue size
    -Packet encoding
    -

Imagine that you and your brother share a car.
sealed trait Condition
object Pristine extends Condition
object Decent extends Condition
object Trashed extends Condition

sealed trait Location
object School extends Location
object Home extends Location
object Restaurant extends Location
object JanesHouse extends Location

class Car(fuel: Int, condition: Condition, location: Location)
class Person(name: String, location: Location) {
  def drive(car: Car, destination: Location) = ???
  def clean(car: Car) = ???
}


var sam = Person("Sam", Home)
var joe = Person("Joe", School)
var mutableCar = Car(100, Pristine, Home)

joe.drive(mutableCar, School) // Error: Joe can't drive a car if he's not in the same location

if (mutableCar.location == Home) // Now we're safe. Sort've.
  sam.drive(mutableCar, School)


if (mutableCar.condition != Pristine)
  joe.clean(mutableCar)
joe.drive(mutableCar, JanesHouse)

if (mutableCar.fuel < 50)
  joe.fill(mutableCar)
sam.drive(mutableCar, Restaurant)
sam.drive(mutableCar, School)
sam.drive(mutableCar, Home)
joe.drive(mutableCar, school) // Error: Out of gas!

case class Car(fuel: Int, condition: Condition, location: Location)




Sculpture Metaphor
  Sculpture volatileSculpture = new MutableSculpture(Materials.Clay, Colors.Red, Status.Unshaped)

  -Sculpture sits in a room, multiple people walk into the room over time, all
  of them altering it in different ways
    -You might try to anchor something to a piece of the sculpture that somebody
    just removed
      volatileSculpture.removeHandles()
      volatileSculpture.polishHandles()
    -When the sculpture was created, it was red, but when you try to add blue
    detailing, you end up drawing blue designs on a blue sculpture.
      volatileSculpture.setColor(Colors.Blue)
      volatileSculpture.addDetailing(/* Vectors for designs */, Colors.Blue)
      
    -It's possible that someone removed the sculpture entirely
      -volatileSculpture = null
      -volatileSculpture.display() // NPE!

  -In the FP world, the person would take the existing sculpture, perform their
  transformation, and then hand it directly to the next person who wanted to use
  it.
    val solidSculpture = new ImmutableSculpture(Materials.Clay, Colors.Red, Status.Unshaped)
    solidSculpture.removeHandles() // Makes new version, then loses it.  Effectively does nothing.
    val sculptureWithNoHandles = solidSculpture.removeHandles()
    solidSculpture.polishHandles() // Works as expected
    sculptureWithNoHandles.polishHandles()  // Obviously incorrect
  
Immutability
  - Less confusion
  - Easier refactoring
  - Statements that are true, are true forever.
      "If things aren't equal forever, were they ever really equal?"
    At most, you can say they happened to be equal at a given instant.
    


  - Builder pattern to demonstrate immutable transformations over mutations
  - Prevent this errors:
      if (n = 0)


Unit
  Unit doesn't mean:
    This function has an unhelpful return type.
  It means:
    "This function has a side effect."
    or
    "This crosses the boundary into the real world."
  Otherwise, there would be no point in executing it!

  Ponder: Why is it okay to have return types in DAO functions?
    I suppose it's because that's the closest you can get to the precipice.
    Internal functions should be the only ones that return Unit, unless you want
    to give full low-level capabilities. Often, you won't.
  

Passing functions as arguments
  -Show similar nested loops in functions, and then show

Iteration vs map
  - Demo a few contrived data structures
    - 4 section square
    - Circular List
    - 3D matrix (MRI data, Videogame Environment, 
    - Multiple Lists (Supermarket Checkout Area, Queue Manager)



Functional Error Handling
  -Exceptions are fine, throwing excepts is not.

// TODO Use Try's/Either's here
  val myList = List(Some(5), None, Some(3), None, Some(3)) 
  val (successes, failures) = myList.partition(x=>x.isDefined)

// Research Example
  val researchTopics = List("Functional Programming", "Object-Oriented Programming", "Imperative Programming", "Dynamic Programming")
  def searchWikipedia(searchTerm: String): Option[HTMLContent]
  def pageSections(content: HTMLContent): List[String]
  def importantRelatedTerms(content: HTMLContent): List[String]
  def linksToTopic(searchTerm: String): List[URL]
  // Only proceed to SO step if there was a Wikipedia entry.
  // TODO Search Stack Overflow for terms
    - Number of questions asked
    - Ratio of answered to unanswered

// Image manipulation example
classpath.add("com.sksamuel.scrimage" %% "scrimage-core" % "2.1.0")
classpath.add("com.sksamuel.scrimage" %% "scrimage-io-extra" % "2.1.0")
classpath.add("com.sksamuel.scrimage" %% "scrimage-filters" % "2.1.0")
- Get all images in directory
- Scale them to consistent size
- Pad them with Demotivational-style border
val inFile = ... // input File
val outFile = ... // output File
// Image.fromFile(inFile).filter(BlurFilter).flipX.output(outFile)(JpegWriter())

-Very nice "in the wild" use of foldLeft here:
  def filter(filters: Filter*): Image = {
    filters.foldLeft(this)((image, filter) => image.filter(filter))
  }

Image.fromFile(inFile).scale(/*scale dimensions*/).pad(/*pad dimensions*/).output(outFile)(JpegWriter())
  - Possible effects to show off:
    - diffuse
    - edge
    - lens flare
    - oil
    - pixelate
    - ripple
    - twirl
    - vintage
  - Generate some sudo-random composite images
  - Maybe add a signature of some type to the meta data?
  - Incorperate a random effect. See if anyone notices, then point out that
    it's a subtle interaction with the real work, via system clock.
    - To be pure, a timestamp must be provided in the function interface.

Git as a functional data structure
  - Immutability doesn't just facilitate concurrent software operations, it
    also works for software developers.
  - Don't waste *any* time arguing about what happened to the code base at any
    given point.
  - Every change is recorded as part of persistent data structure
  - This structure is *completely* reproducable at any moment
  - Adding a new root node to the tree is cheap and efficient, so common commit and
    branching commands are *fast*.
  - Hash's ensure that nothing is tweaked later
  - Can operate on every commit concurrently
  - BFG example (aka project Identity Theft
    - Remove Linus from entire project history?
    - "Linus" -> "Bill"
    - "Torvalds" -> "Frasure"
    - "ltorvalds@linux.com" -> "bill.frasure@gmail.com"

Fun/Important Scala Projects
- ScalaFiddle
- ScalaJS
- ScalaTags
- ScalaCSS
- Ammonite
- ScalaTest
- ScalaZ (?)
- Cats (?)
- ScalaMeta (?)

Fun/Important FP Projects
- Haskell type-based search engine
